#### 题外话：有关作业6点评中a开头的单词都没有出现：

​		作业时误以为a开头的单词都被短于3或停用词过滤掉了，就没有考虑这个问题。经过仔细排查后，发现问题出现在代码内部：

```java
for (String pattern : patternsToSkip) {
                line = line.replaceAll(pattern, "");
            }
```

​		因为停用词中有“a”，代码直接replace了所有的字母a为空，比如abroad变成了brod，不仅让a开头的单词变成了这里的b开头的单词，而且删掉了所有单词中的a，同理其它出现在停用词表中的单词组合都被替代掉了，说明这里的replaceAll方法虽然是适合停用标点符号，但是不适合停用单词的。一种解决办法可以是通过传参分辨两个文件，针对两个不同的pattern，标点的使用replaceAll，单词在去除标点后分词，针对再replaceAll，这里不再赘述。

### 作业7

​		这次采用KNN作为分类算法的演示，一个是计算量小，一个是思路容易理解，本想着结合机器学习导论的课程内容使用决策树，但是离散值的决策树还是在mapreduce中并不容易处理，主要表现在类似KNN使用高斯函数等进行优化时一样还需要调参，不容易把握，于是选用了简单的。

Usage: bin/hadoop jar KNN.jar  <train> <test> <out> <k>

​		四个参数分别为训练集位置、测试集位置、结果输出位置、k值。数据切割和结果分析均单独使用py脚本完成。jar包在out文件夹中。

#### 模块功能

- mapper：setup读入测试集，每一行存为一个list，再将这些list存入一个测试集test中；map计算测试样本与训练集样本距离，键为行号，值为距离+label
- combiner：设定k值，排序选择前k个作为结果。
- reducer：将结果进行输出。

参考https://github.com/guoguozy/Hadoop_knn

#### 运行截图

![1](/image/1.png)

​		这次数据量少，运行起来比较轻松，个人pc可以跑动。

![2](/image/2.png)

​		得到结果，拿出来单独比较。

![3](/image/3.png)

​		由于train_test_split对数据的切分在随机状态给定时保持一致，可以省去一部分导入文件的麻烦。将使用了简单的投票决定分类的结果和真实结果比较，有84%的精度，还是很不错的，当然很多地方有待改进。这里没想到好的可视化方法，ROC，P-R图等似乎都不适用，主要可能因为结果有些简单而没有可视化的必要。

#### 改进思考

- 从数据集方面，由于主要精力放在写代码上了，没有在意数据本身是否存在异常值等，没有进行数据清洗，很显然是很影响结果精度的。


- 从算法方面，可以改进KNN的加权函数，包括使用反函数和高斯函数等。


- 从数据结构方面，反复读取类似文本的数据结构也很吃算力，如有可能应新建成更易读易写的数据结构。

